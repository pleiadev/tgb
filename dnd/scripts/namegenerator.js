// <!--


///// Beginning of Doublet Data File Parsing Functions /////

//
// The language confluxer takes a list of words and associates
// every sequential pair of letters with the list of letters that
// might possibly follow the pair. The command "lc -s [datafile]"
// will show you what this looks like. The program chooses a pair
// that can occur at the beginning of a word, then selects one of
// the letters from the associated list, and forms a new pair,
// repeating until a whitespace character is found or until a
// max-length is reached. Simple.
//

//
// Saved File
//
// Doublet File Format
// <?xml version="1.0"?>
// <doublet-list>
//   <doublet pair="ab">charactersindoublelist</doublet>
//   <doublet pair="cd">charactersindoublelist</doublet>
// </doublet-list>
//



function readTextFile(file)
{
    var rawFile = new XMLHttpRequest();
	rawFile.async = false;
    rawFile.open("GET", file, false);
    rawFile.onreadystatechange = function() {
        if (rawFile.readyState === 4)
        {
            if (rawFile.status === 200 || rawFile.status == 0)
            {
                var allText = rawFile.responseText;
                Dbg(allText);
				return;
            }
        }
    }
	Dbg("???");
    rawFile.send(null);
}


function LCReadDoubletList(filepath) 
{
	var dic = new Object(); // char pair map
	//var dic = new Array(); // char pair map

	try
	{
		Dbg(filepath);
		
		readTextFile(filepath); 
		
		Dbg(typeof(document.getElementById("compiled_names")))
		Dbg(document.getElementById("compiled_names").href)

		parser = new DOMParser();
		xmlDoc = parser.parseFromString(document.getElementById("compiled_names"),"text/xml");
		Dbg(typeof(xmlDoc))

		tt = xmlDoc.getElementsByTagName("doublet-list");
		Dbg(typeof(tt));
		//compiled_names = ;
		if(compiled_names.href.indexOf(filepath) == -1)
		{
			compiled_names.async = false;	
			compiled_names.href = filepath; // XML
		}

		//if( compiled_names.parseError.errorCode )
		//{
		//	Msg( filepath + "(" + compiled_names.parseError.Line + ") Error = " + compiled_names.parseError.errorCode + " : " + compiled_names.parseError.reason );
		//}
		Msg(typeof(compiled_names));

		var nodes = compiled_names.selectNodes("//doublet");
		if( nodes == null ) return ret;
	
		for( i = 0; i < nodes.length; i++ )
		{
			var node = nodes(i);
			var attrib = node.getAttribute("pair");
			if( attrib != null )
			{
				dic.Add( attrib, node.text);
				//dic[attrib] = node.text;
			}
		}
	}
	catch(e)
	{
		if( e.number != 0 )
		{
			ret = "Error: " + e.number;
			ret += ", was generated by " + e.source;
			ret += String.fromCharCode(13);
			ret += " Description: " + e.description;
			Msg( ret );
		}
	}

	return dic;
}

///// Ending of Doublet Data File Parsing Functions /////


///// Beginning of Word Generation Functions /////

function LCGenerateWords(dic, count, chars_max, chars_min) 
{
	var words = new Array();

	try
	{
		if( dic == null || dic.Count < 1 )
		{
			Msg("Could not find imported data! Make sure the data file was imported successfully.");			return;
		}

		var re = /\s/gi;
		var doublet = "";
		var word = "";
		var ch = "";
		var tail = null;
		
		var keys = (new Array(dic.Keys())).toArray();
    
		while( words.length < count )
		{
			// BUGBUG note double can contain a space it needs to be trimmed prior to 
			// testing the length of the array
			if( (doublet.replace(re, "")).length < 2 )
			{
				// Lookup random two letter pair
				var r = Math.floor(Math.random() * dic.Count);
				doublet = keys[ r ];
				//throw( new Error( 2, "doublet = " + doublet + ", r = " + r));
				word = doublet;
			}

			// Get tail character string
			tail = new String( dic.Item( doublet ));
			if(tail == null) throw( new Error(2,"{" + doublet + "} = " + tail));
        
			// pick a random tail character
			ch = tail.substr(Math.floor(Math.random() * tail.length), 1);
			if( ch.length == 0 ) ch = " ";
			//window.alert( "doublet = " + doublet + ", ch = " + ch + ", tail = " + tail);
        
			if( ch.match(re) != null )
			{
				if( word.length >= chars_min )
				{
					words[words.length] = word;
				}
				word = ""; // On next pass start new word
			}
			else
			{
				word += ch;
			}
          
			if( word.length == chars_max )
			{
				words[words.length] = word;
				word = ""; // On next pass start new word
			}
        
			// Second character in the doublet + random tail character forms new doublet
    	    doublet = doublet.charAt(1) + ch;
		}
    
	}
	catch( e )
	{
		if( e.number != 0 )
		{
			Msg("Error: " + e.number + ", was generated by " + e.source + String.fromCharCode(13) + " Description: " + e.description);
		}
	}

	return words;
}


function LCProperNames( words, vowel_max ) 
{
	var names = new Array();

	try
	{
		var re = /[aeiou]/gi;
	
		var sname = new Array();
		var lname = new Array();
	
		var s = ""; 
		for( i = 0; i < words.length; i++ )
		{
			s = words[i];

			var matches = s.match(re);
			if( matches == null )
				continue;
			
			if( matches.length < vowel_max )
				sname[sname.length] = s;
			else
				lname[lname.length] = s;
		}
		
		var name_count = ( sname.length > lname.length ) ? lname.length : sname.length;
		
		var a = "";
		var b = "";
	
		for( i = 0; i < name_count; i++ )
		{
			a = sname[i];
			a = (a.charAt(0)).toUpperCase() + a.substr(1);

			b = lname[i];
			b = (b.charAt(0)).toUpperCase() + b.substr(1);
			if( Math.floor( Math.random() * 1) == 1 )
				s = a + " " + b;
			else
				s = b + " " + a;
			
			names[i] = s;
		}
    
		if( name_count > 0 )
			Msg("Name Generation Succeeded!");
		else
			Msg("No Names Generated.");
	}
	catch( e )
	{
		if( e.number != 0 )
		{
			Msg("Error: " & e.number & ", was generated by " + e.source + String.fromCharCode(13) + " Description: " + e.description);
		}
	}

	return names;
}

///// Ending of Word Generation Functions /////

///// Beginning of Message Output Functions /////

function Dbg( s )
{
	window.alert(s);
}

function Msg( s )
{
	display("statusArea", s);
}

<!-- display text function -->
var NS = (document.layers) ? 1 : 0;
var NS6 = (document.getElementById) ? 1 : 0;
var IE = (document.all) ? 1 : 0;

function display(id, str) 
{
	if (NS) 
	{
    	with (document[id].document) 
		{
			open();
    		write(str);
			close();
		}
	}
	else if (NS6)
	{
    	document.getElementById(id).innerHTML = str;
	}
	else
	{
		document.all[id].innerHTML = str;
	}
}

///// Ending of Message Output Functions /////


function generate(source, word_count, word_max, word_min )
{
	//Msg(source)
	var dic = LCReadDoubletList( source );

	return LCGenerateWords(dic, word_count, word_max, word_min);
}


function generateWords()
{
	// Read Inputs
	var names_source = document.form1.names_source.value; 
	var word_max = document.form1.word_maximum.value; 
	var word_min = document.form1.word_minimum.value; 
	var word_count = document.form1.word_count.value; 
	var vowel_max = document.form1.vowel_maximum.value; 
	var name_count = document.form1.name_count.value; 

	/*	
	names += "names_source = " + names_source;
	names += ", word_max = " + word_max;
	names += ", word_min = " + word_min;
	names += ", word_count = " + word_count;
	names += ", vowel_max = " + vowel_max;
	names += ", name_count = " + name_count;
	*/

	var words = generate(names_source, word_count, word_max, word_min );
	
	var names = LCProperNames( words, vowel_max );

	var name_list = "";	
	for(i in names)
	{
		name_list += "<BR/>";
		name_list += " " + names[i];
	}
	
	display("theNames", name_list);
}


// -->

