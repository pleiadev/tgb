// <!--

///// Beginning of Parsing Functions /////

//
// The language confluxer takes a list of words and associates
// every sequential pair of letters with the list of letters that
// might possibly follow the pair. The command "lc -s [datafile]"
// will show you what this looks like. The program chooses a pair
// that can occur at the beginning of a word, then selects one of
// the letters from the associated list, and forms a new pair,
// repeating until a whitespace character is found or until a
// max-length is reached. Simple.
//
function LCParseFile(filename, path) 
{
	var dic = new ActiveXObject("Scripting.Dictionary"); // char pair map

	try
	{
		ret = "Failed! Cause Unknown.";
       
		// Check path. Use current spread sheet directory
		// when filename does not resolve
		var fs = new ActiveXObject("Scripting.FileSystemObject");
		
		if( fs.FileExists(filename) )
		{
			fn = filename;
		}
		else if( path != null && fs.FileExists( fs.BuildPath(path, filename) ) )
		{
			fn = fs.BuildPath(path, filename);
		}
		else
		{
			Msg("File Not Found, " + filename);
			return dic;
		}
    
		var f = fs.GetFile(fn);
		var ts = f.OpenAsTextStream(1); // 1 = ForReading
    
		LCReadWords( ts, dic );
		
		ts.Close();
		
		ts = null;
		f = null;
		fs = null;
	}
	catch(e)
	{
		if( e.number != 0 )
		{
			ret = "Error: " + e.number;
			ret += ", was generated by " + e.source;
			ret += String.fromCharCode(13);
			ret += " Description: " + e.description;
			Msg( ret );
		}
	}

	return dic;
}

function LCReadWords(ts, dic)
{
	re = /\S/i;
	var w = "";
	var ch = "";
	
	while( ts.AtEndOfStream != true )
	{
		ch = ts.Read(1);
        
		if( ch == "#"  )
		{
			ts.ReadLine( ); // Skip comment
		}
		else if( ch.match( re ) != null )
		{
			w += ch;
		}
		else if( w.length > 0 )
		{
			//w += " ";
			LCProcessWord( w, dic );
			w = "";
		}
		else
		{
			w = "";
		}
	}
}

//
// LC Dictionary Format:  xx { yyyyyyyyyyyy }
// xx			--	two letter (doublet) dictionary index.
// yyyyyyyyyy	--	string of characters that have appeared after the doublet in
//					word source file.
//
function LCProcessWord(w, dic)
{
	var doublet = "";
	var tail = "";

	for( c = 0; c < w.length - 1; c++ )
	{
		doublet = w.substr(c, 2);
		tail = w.substr(c + 2, 1);

		if( dic.Exists(doublet) == false )
		{
			dic.Add( doublet, tail );
		}
		else
		{
			// Add tail character at the end of the array		
			var tail2 = dic.Item(doublet) + tail;
			dic.Item(doublet) = tail2;
			//Msg( "{" + doublet + "} = " + tail2 );
		}
	}
}

///// End of Parsing Functions /////



///// Beginning of Doublet Data File Parsing Functions /////



//
// Saved File
//
// Doublet File Format
// <?xml version="1.0"?>
// <doublet-list>
//   <doublet pair="ab">charactersindoublelist</doublet>
//   <doublet pair="cd">charactersindoublelist</doublet>
// </doublet-list>
//
function LCWriteDoubletList(filepath, dic) 
{
	var ret = "";

	try
	{
		ret = "Failed! Cause Unknown.";

		var ForReading = 1, ForWriting = 2;

		// Check path. Use current spread sheet directory
		// when filename does not resolve
		var fso = new ActiveXObject("Scripting.FileSystemObject");
		var doublet = fso.CreateTextFile( filepath, true );

		// Write header
		var file_header = "<?xml version=\"1.0\"?>";
		file_header += String.fromCharCode(13);
		file_header += String.fromCharCode(10);
		file_header += "<doublet-list>";
		doublet.Write( file_header );

		// Write Data
		var keys = (new VBArray( dic.Keys() )).toArray();
		for( i = 0; i < keys.length; i++ )
		{
			var file_entry = String.fromCharCode(13);
			file_entry += String.fromCharCode(10);
			file_entry += "<doublet pair=\"";
			file_entry += keys[i];
			file_entry += "\">";
			file_entry += dic.Item(keys[i]);
			file_entry += "</doublet>";
			doublet.Write( file_entry );
		}

		// Write footer
		var file_footer = "";
		file_footer += String.fromCharCode(13);
		file_footer += String.fromCharCode(10);
		file_footer += "</doublet-list>";
		doublet.Write( file_footer );

		doublet.Close( );
		doublet = null;

		ret = "Succeeded!";
	}
	catch(e)
	{
		if( e.number != 0 )
		{
			ret = "Error: " + e.number;
			ret += ", was generated by " + e.source;
			ret += String.fromCharCode(13);
			ret += " Description: " + e.description;
			Msg( ret );
		}
	}

	return ret;
}

//
// Not used in this hta. This code is used in the name generator and this 
// code is for validating th loading mechanism for that page.
//
function LCReadDoubletList(filepath) 
{
	var dic = new ActiveXObject("Scripting.Dictionary"); // char pair map
	//var dic = new Array(); // char pair map

	try
	{
		compiled_names.async = false;	
		compiled_names.src = filepath; // XML

		if( compiled_names.parseError.errorCode )
		{
			Msg( filepath + "(" + compiled_names.parseError.Line + ") Error = " + compiled_names.parseError.errorCode + " : " + compiled_names.parseError.reason );
		}

		var nodes = compiled_names.selectNodes("//doublet");
		if( nodes == null ) return ret;
	
		for( i = 0; i < nodes.length; i++ )
		{
			var node = nodes(i);
			var attrib = node.getAttribute("pair");
			if( attrib != null )
			{
				dic.Add( attrib, node.text);
				//dic[attrib] = node.text;
			}
		}
	}
	catch(e)
	{
		if( e.number != 0 )
		{
			ret = "Error: " + e.number;
			ret += ", was generated by " + e.source;
			ret += String.fromCharCode(13);
			ret += " Description: " + e.description;
			Msg( ret );
		}
	}

	return dic;
}

///// Ending of Doublet Data File Parsing Functions /////


///// Beginning of Data File Compilation Routines /////

function MakeDataFilePath( filepath )
{
	var fso = new ActiveXObject("Scripting.FileSystemObject");
	return fso.GetBaseName(filepath) + ".xml";
}

function compile( filename )
{
	Msg("Parsing and compiling names file: " + filename );
	
	var dic = LCParseFile( filename );

	var compiled = MakeDataFilePath( filename );

	Msg("Compilation completed! Saving result set in " + compiled);
	LCWriteDoubletList(compiled, dic);

	Msg("Reload file to verify data.");
	var dic = LCReadDoubletList( compiled );

	Msg("Finished compile.");
}

function isCompilationUpToDate( filename )
{
	var names_compiled = MakeDataFilePath( filename );
	var fso = new ActiveXObject("Scripting.FileSystemObject");

	var sf = fso.GetFile(filename);
	var xf = fso.GetFile(names_compiled);

	return Date.parse(xf.DateLastModified) > Date.parse(sf.DateLastModified) ? true : false;
}

///// Ending of Data File Compilation Routines /////


///// Beginning of Message Output Functions /////

function Msg( s )
{
	//window.alert(s);
	display("statusArea", s);
}

<!-- display text function -->
var NS = (document.layers) ? 1 : 0;
var NS6 = (document.getElementById) ? 1 : 0;
var IE = (document.all) ? 1 : 0;

function display(id, str) 
{
	if (NS) 
	{
    	with (document[id].document) 
		{
			open();
    		write(str);
			close();
		}
	}
	else if (NS6)
	{
    	document.getElementById(id).innerHTML = str;
	}
	else
	{
		document.all[id].innerHTML = str;
	}
}

///// Ending of Message Output Functions /////




function compileNames()
{
	var names_source = document.form1.names_source.value; 

	compile( names_source );
}




// -->

